' Gambas class file

Public Enum rText, rTokens, rTypes, rPosition

Public ProgramLines As New String[]                                          ' List of all program lines
Public ProgramSymbols As New Variant[]                                  ' List of all tokens
Public ProgramTypes As New Variant[]                                       ' List of all 
Public ProgramPositions As New Variant[]                                ' Position of token text in each line
Public GlobalItemPosition As New Integer[]                              ' Position of each Globaly define variable
Public sSourceFile As String = ""                                                     ' The Source File

Private CurrentLineNumber As New Integer[]                           ' Current line number of text in a file

Public CurrentLine As Integer = -1                                                         ' current line being processed
Public CurrentToken As Integer = -1                                                      '  we have not gotten first token yet
Public key As Integer = -1                                                                          '  the key to the datasets
Private MainDef As New Collection(gb.ignorecase)                         '  Points to main if found in this file


Private BlockList As New Integer[]                                                          '  List of all discovered block definitions start
Private BlockLineNumbers As New Integer[]                                       ' Line number of the definition
Private BlockNames As New String[]                                                      '  List of the block names being created
Public BlockDefined As New Collection(gb.ignorecase)                   '  Collection of defined blocks
Public BlockType As New String[]                                                             ' Type of block being created

Private $bInClass As Boolean = False                                                          '  Processing a class block
Private cIncludedFiles As New Collection(gb.Ignorecase)                   ' List of already included files, only load included files once
Private cIncludeStack As New String[]                                                       ' List of files included into this build, to check for circular refrence
Private sDefaultFilePath As String = ""                                                      ' Directory to look for included file with no full path defined
Private bPublicOrSubDef As Boolean = False                                          ' Used to indicate that the script contained public or Subroutines
Private aWarnings As New String[]                                                             ' Builds an array of possible warnings
Private $oContext As Context                                                                      ' all the global variables
Private $sEntryPoint As String = "MAIN"                                   'Defines the default type of entry point for the generated program

Private $cBlockTypes As Collection = ["MODULE": ["END", "MODULE"],
                                                                          "CLASS": ["END", "CLASS"],
                                                                          "FORM": ["END", "FORM"],
                                                                          "CONNECTION": ["END", "CONNECTION"],
                                                                          "WEBFORM": ["END", "WEBFORM"],
                                                                          "WEBPAGE": ["END", "WEBPAGE"]
                                                                         ]
Private $sCurrentBlock As String = ""
Static Public $sScriptFilter As New Collection

Public Sub _New(cContext As Context, Optional SourceFile As String = "", Sourceprogram As String = "")
  Dim SourceBuffer As String
  
  $oContext = cContext                                                                         ' Access to global variables
  cIncludeStack.Push(SourceFile)                                                       ' Add this file to the stack for processing
  sDefaultFilePath = File.Dir(SourceFile)                                         ' Set the default file path to use for includes
  sSourceFile = SourceFile
  
  If SourceProgram <> "" Then                                                           ' Updated to correctly process -e thru full process for -e < filename cases
     SourceBuffer = SourceProgram
  Else If SourceFile = "" Then 
      SourceBuffer = GetStdio()
  Else
     $oContext.$aIncFiles.Add(SourceFile)
     $oContext.$aIncFiles.Add(Stat(SourceFile).LastModified)
     SourceBuffer = GetFile(SourceFile)
     Verbose("Processing Script File : " & File.Name(SourceFile))
  Endif
  
  TokenizeFile(SourceBuffer)
  
End

Public Sub GetStdio() As String

  Dim buffer As String
  Dim SourceBuffer As String = ""
  
  While Not Eof(File.in)
    buffer = Read -256
    SourceBuffer &= buffer
  Wend
  
  Return SourceBuffer
  
End

Private Sub GetFile(SourceFile As String) As String
  Dim buffer As String 
  
  Try Buffer = File.Load(SourceFile)
  
  If Error Then
    Error.Raise("Unable to read file : \"" & SourceFile & "\"")
  Endif
  
  Return buffer
  
End

Private $cKeywords As Collection = ["PRIVATE": True, "PUBLIC": True, "STATIC": True, "SUB": True, "FUNCTION": True, "PROCEDURE": True, "STRUCT": True, "ENUM": True, "CLASSREF": True]

Private Sub TokenizeFile(SourceBuffer As String)
  Dim SourceList As String[]
  Dim sClassName As String = ""
  Dim MainPos As Integer = 1
  Dim sline As String
  Dim bDoFilter As Boolean = ($sScriptFilter.count > 0)
  
  $cKeywords.default = False
  
  If $oContext.$bPlugin Then $sEntryPoint = "_Call"
  
  CurrentLineNumber.Push(0)
  
  SourceList = Split(SourceBuffer, "\n", "", True)
  For Each sLine As String In SourceList
    
    If bDoFilter Then ScriptKeywordFilter(sLine, $sScriptFilter, CurrentLineNumber.last, cIncludeStack.last) 'filter the script if needed
      
    Inc CurrentLineNumber.last
    
    If Left(sLine, 3) = "#!/" Then sLine = "' " & sLine  ' eliminate the script header
    
    Highlight.Analyze(sLine)
    
    Dim aTypes As Integer[] = Highlight.Types
    Dim symbols As String[] = Highlight.symbols
    
    '' Here we look for any definition which will be a seperate source type or includes other sources
    '' Building the source pool as we go
   
    '' Check for The definition of main, Knowing this speeds up process of program portion of the script
    If aTypes.count >= 4 And If aTypes[0] = Highlight.Keyword Then
      MainPos = 1
      If symbols[0] = "PUBLIC" And aTypes[1] = Highlight.keyword Or If aTypes[1] = Highlight.symbol Then
        If aTypes[1] = Highlight.symbol Then MainPos = 0
        If symbols[MainPos] = "SUB" Or If symbols[MainPos] = "PROCEDURE" Or If symbols[MainPos] = "FUNCTION" Then
          If Upper(symbols[MainPos + 1]) == $sEntryPoint Then
              If aTypes.count = 4 Then
                Warning(Subst("&1 Was Not Declared as Public, assuming Public Sub &1", $sEntryPoint))
                sLine = "Public " & sline 
              Endif
              MainDef.Add(CurrentLineNumber.last, cIncludeStack.last)
              If MainDef.count > 1 Then 
                Warning(Subst("Multiple &1 Definitions :", $sEntryPoint), True)
                For Each i As Integer In MainDef       
                  Verbose(Subst("&1 Defined : &2", $sEntryPoint, Quote(MainDef.key) & "." & i), True)
                Next
                CompileError(cIncludeStack.last, CurrentLineNumber.last, "Too Many " & $sEntryPoint & " Definitions")
              Else
                Verbose($sEntryPoint & " Defined  : " & cIncludeStack.last & "." & CurrentLineNumber.last)
              Endif
          Endif
        Endif
      Endif
    Endif
    
    '' Check for specific keywords that trigger reliance upon MAIN being defined
    If symbols.count > 0 And If aTypes[0] = Highlight.keyword Or $cBlockTypes.Exist(Upper(symbols[0])) Then
       
        If symbols[0] = "EXPORT" Then
          $oContext.$bExport = True
          sLine = "' " & sLine
          Goto ContinueRecord
          
        Else If Not $bInClass And If $cKeywords[symbols[0]] Then
            aWarnings.Add("Warning : Defined without " & $sEntryPoint & " : " & symbols[0] & ":" & File.name(cIncludeStack.last) & "." & CurrentLineNumber.last & " : " & sline)
            bPublicOrSubDef = True
            GlobalItemPosition.Add(ProgramLines.count)
             Goto ContinueRecord
             
        Else If Not $bInClass And If symbols[0] = "FAST" Then
          
          If aTypes.count > 2 Then
               aWarnings.Add("Warning : Defined without " & $sEntryPoint & " : " & symbols[0] & ":" & File.Name(cIncludeStack.last) & "." & CurrentLineNumber.last & " : " & sline)
             bPublicOrSubDef = True
             GlobalItemPosition.Add(ProgramLines.count)
             Goto ContinueRecord
             
          Else If $oContext.$bFast = True Then   ' already defined
               Warning("FAST Duplicate Definition at " & File.Name(cIncludeStack.last) & "." & CurrentLineNumber.last)
               sLine = "' " & sLine
               Goto ContinueRecord
               
          Else If aTypes.count = 1 Then
             Verbose("FAST(Jit) activated for Module:" & File.name(cIncludeStack.last) & "." & CurrentLineNumber.last)
             $oContext.$bFast = True
             sLine = "' " & sline
             Goto ContinueRecord
             
          Else If aTypes.count = 2 And If symbols[1] = "UNSAFE" Then
            Verbose("FAST UNSAFE(Jit and nochecks) activated for Module:" & File.name(cIncludeStack.last) & "." & CurrentLineNumber.last)
            $oContext.$bFast = True
            $oContext.$bUnsafe = True
            sLine = "' " & sline
            Goto ContinueRecord
            
          Else
            CompileError(cIncludeStack.last, CurrentLineNumber.last, "UnKnown Entry : " & symbols[0] & " Following 'FAST'  Definition")
          Endif
      
          '' check for inclusion of Components or libraries
        Else If symbols[0] = "USE" 
            If symbols.count >= 2 Then
                 ProcessUse(sLine)
                Continue
            Else
                CompileError(cIncludeStack.last, CurrentLineNumber.last, "USE statement without component or library definitions")
            Endif 
            
          '' Check for the end of a class definition 
        Else If symbols[0] = "END" And symbols.count = 2 Then      
          
          If aTypes[1] = Highlight.symbol Or aTypes[1] = Highlight.keyword And If symbols[1] == $sCurrentBlock Then
             If Not $bInClass Then
               CompileError(cIncludeStack.last, CurrentLineNumber.last, "Syntax error : Unexpected : " & sLine)
             Endif
             sClassName = BlockNames.Pop()
             BlockType.Pop()
             BlockDefined.Add(ProcessClass(sClassName, BlockList.Pop(), BlockLineNumbers.Pop(), Lower($sCurrentBlock)), sClassName & "." & $sCurrentBlock)
             $bInClass = False
             Continue
          Endif 
        Endif
        
         '' Check for the definition of a block and make where it is defined
        If $cBlockTypes.Exist(Upper(symbols[0])) Then 
          
             $sCurrentBlock = (Upper(symbols[0]))
             If symbols.count < 2 Then
               CompileError(cIncludeStack.last, CurrentLineNumber.last, Subst("&1 : Name Missing ", $sCurrentBlock))
            Endif 
            If aTypes[1] = Highlight.symbol Then
                If $bInClass Then
                    If symbols[0] == "class" And If $sCurrentBlock == "class" Or $sCurrentBlock == "module" Then
                       Warning("Found class definition inside a &1, Assuming that it is a class refrence not the beginning of a new class")
                       Goto ContinueRecord
                    Else 
                       CompileError(cIncludeStack.last, CurrentLineNumber.last, Subst(" &1 : Unexpected &1 definition inside &1 definition : ", $sCurrentBlock) & sLine)
                    Endif 
                Endif
                Dim cdefBlock As ClassDef = BlockDefined[symbols[1] & "." & $sCurrentBlock]
                If Not IsNull(cdefBlock) And If cdefBlock.sExtention == $sCurrentBlock Then 
                   CompileError(cIncludeStack.last, CurrentLineNumber.last, $sCurrentBlock & " : " & symbols[1] & " Already defined")
                Endif
                Verbose("Begin to define Block : " & $sCurrentBlock & " : " & symbols[1])
                BlockList.Push(ProgramSymbols.Count)
                BlockNames.Push(symbols[1])
                BlockLineNumbers.Push(CurrentLineNumber.last)
                BlockType.Push($sCurrentBlock)
                $binClass = True
                Continue
            Endif
            
        Endif
    Endif
    
     ''Check for an include statement -- Include is not a keyword, perhaps it should be
    If aTypes.count >= 2 And If aTypes[0] = Highlight.symbol And If aTypes[1] = Highlight.string And If symbols[0] == "INCLUDE" Then
         Warning("'Include' is Replaced by '#Include' and may not be supported in future releases")
         ProcessInclude(symbols, atypes, sDefaultFilePath)
         Continue
         
     '' Check for PreProccessor  lines
    Else If aTypes.count >= 2 And If aTypes[0] = Highlight.Preprocessor Then
        If symbols[0] == "#SCRIPT" Then 
           Highlight.Analyze(Right(Trim(sline), -1))
          ScriptPreProcess(Highlight.symbols, Highlight.types, CurrentLineNumber.last, cIncludeStack.last)
           sLine = "'" & sLine
           Goto ContinueRecord
           
        Else If symbols[0] == "#INCLUDE" Then
           ProcessInclude(symbols, atypes, sDefaultFilePath)
           Continue
        Endif
    Else If aTypes.count = 2 And If symbols[0] == "CLASSREF" And If aTypes[1] = Highlight.symbol
      sline = Replace(sLine, "ClassRef", "Class", gb.ignorecase)
      $oContext.$sProgramHeader &= sLine & "\n"
      Continue
    Endif
    
ContinueRecord:

    ProgramLines.Add(sLine)
    ProgramSymbols.Add(Highlight.symbols)
    ProgramTypes.Add(Highlight.types)
    ProgramPositions.Add(Highlight.Positions)
    
  Next
  
  If BlockNames.count > 0 Or If $bInClass Then 
    If $sCurrentBlock == "class" Then 
        BlockList.Pop()
        BlockType.Pop()
        Warning(Subst("Class '&1' Defined in Script at Line &2, No End Class encountered, Assuming this was a class refrence not a class definition", BlockNames.Pop(), BlockLineNumbers.Pop()))
    Else
        CompileError(cIncludeStack.last, CurrentLineNumber.last, "Missing 'END " & $sCurrentBlock & "' For " & $sCurrentBlock & ": " & BlockNames.Pop())
    Endif
  Endif
  
  CurrentLineNumber.Pop()
End

Public Sub ProcessClass(name As String, Start As Integer, DefLine As Integer, Optional ClassType As String = "class") As ClassDef
   Dim cDef As ClassDef
   
   Verbose("Defining " & ClassType & " : " & name & " in script file : " & UnQuote(File.Name(cIncludeStack.last)) & "." & DefLine)
   cDef = New ClassDef(name, ProgramLines.Extract(start, -1), ProgramSymbols.Extract(start, -1), ProgramTypes.Extract(start, -1), ProgramPositions.Extract(start, -1), ClassType)
   cDef.iLineNumber = DefLine
   cDef.sDefinedIn = cIncludeStack.last
   Return cDef
End

Public Sub ProcessUse(sLine As String)
  
  Warning("Use :" & File.Name(cIncludeStack.last & "." & CurrentLineNumber.last & ":" & sLine))
  UseLibComp(cIncludeStack.last, CurrentLineNumber.last, sLine)
  
End

Public Sub UseList() As String

Dim UseCompLibList As String = ""

If UseLibComp.HasComponents Then
  UseCompLibList = CComponent.ComponentEntries()
Endif

If UseLibComp.HasLibraries Then
  UseCompLibList &= Libraries.LibraryEntries()
Endif
  
Return UseCompLibList

End


Public Sub ProcessInclude(Includes As String[], atypes As Integer[], sDefaultPath As String)
  Dim buffer As String
  Dim sFilePath As String
  Dim Start As Integer = 1
  For i As Integer = Start To Includes.Max
    If Trim(Includes[i]) = "" Then Continue
    If Includes[i] = "," Then Continue
    If aTypes[i] = Highlight.comment Then Break
    
    sFilePath = UnQuote(Includes[i])
    If File.Dir(sFilePath) = "" Then 
            sFilePath = sDefaultPath &/ sFilePath 
    Endif
    
    If cIncludedFiles[sFilePath] Then Continue                                  ' we only include things once
    Verbose("Including script file :  " & sFilePath & " From File : " & cIncludeStack[cIncludeStack.max] & "." & CurrentLineNumber.last)
    
    If cIncludeStack.Find(sFilePath) > -1 Then
       Warning(cIncludeStack.last & ":" & CurrentLineNumber.last & ":" & "Include \"" & sFilePath & "\" Possible Circular Refrence")
       Continue
    Else
       cIncludeStack.Push(sFilePath)
    Endif
   
    $oContext.$aIncFiles.Add(sFilePath)
    $oContext.$aIncFiles.Add(Stat(sFilePath).LastModified)
    buffer = GetFile(sFilePath)
    TokenizeFile(buffer)  
    
     cincludedFiles.Add(CurrentLineNumber.last, cIncludeStack.Pop())          ' Keep Track of what is already included
     
  Next
  
End


Public Sub Eof() As Boolean
  
  If currentLine + 1 > ProgramLines.max Then
     Return True
  Endif
  Return False
  
End

Public Sub advance() As String[]
  If currentline = ProgramLines.max Then
    Return Null
  Endif

   Inc CurrentLine
   CurrentToken = -1
  Return ProgramSymbols[CurrentLine]
  
End

Public Sub NextToken() As String
  
  If CurrentToken + 1 > ProgramSymbols[CurrentLine].max Then
    advance()
  Else
    Inc CurrentToken
  Endif
  Return ProgramSymbols[CurrentLine][CurrentToken]
  
End

Public Sub backToken() 
  
  If CurrentToken = 0 Then
    back()
  Else
    Dec CurrentToken
  Endif
  
End


Public Sub back(Optional count As Integer = 1)
  
  If CurrentLine - count >= 0 Then
    CurrentLine -= count
  Else
    CurrentLine = -1
  Endif
  CurrentToken = ProgramSymbols[CurrentLine].max
End


Public Sub Text(Optional index As Integer = CurrentLine) As String
  
  If index >= 0 And index <= ProgramLines.max Then
    Return ProgramLines[index]
  Else
    Error.Raise("Out of bounds Program Text Line Number : " & index)
  Endif
  
End

Public Sub Tokens(Optional index As Integer = CurrentLine) As String[]
  
   If index >= 0 And index <= ProgramLines.max Then
    Return ProgramSymbols[index]
  Else
    Error.Raise("Out of bounds Program Tokens Line Number : " & index)
  Endif
  
End

 Public Sub Types(Optional index As Integer = CurrentLine) As Integer[]
 
  If index >= 0 And index <= ProgramLines.max Then
    Return ProgramTypes[index]
  Else
    Error.Raise("Out of bounds Program Types  Line Number : " & index)
  Endif
  
End

Public Sub Positions(Optional index As Integer = CurrentLine) As Integer[]
 
  If index >= 0 And index <= ProgramLines.max Then
    Return ProgramPositions[index]
  Else
    Error.Raise("Out of bounds Program Positions  Line Number : " & index)
  Endif
  
End

Public Sub _get(index As Integer, Optional Setof As Integer = rText, SubIndex As Integer = -1) As Variant
  
  Dim result As Variant[]
  
  Select Case Setof
    Case rText
      Return Text(index)
    Case rTokens
      Result = Tokens(index)
    Case rTypes
      Result = Types(index)
    Case rPosition
      Result = Positions(index)
  End Select
  
  If SubIndex >= 0 Then
    If subIndex < result.Count Then
       Return result[SubIndex]
    Else
      Error.Raise("Out of bounds Program  Get Line Number : " & index)
    Endif
    
  Endif
End

Public Sub _next() As String[]
  
  If Enum.index = Null Then
    Enum.index = 0
  Else
    Inc Enum.index
  Endif
  If Enum.index > ProgramLines.max Then
     Enum.Stop
  Else
    Return ProgramSymbols[Enum.Index]
  Endif
End

Public Sub IsMainDefined() As Boolean
  
  If MainDef.count > 0 Then
    Return True
  Endif
  Return False
End

Public Sub HasBlocks() As Boolean
  
  If BlockDefined.count > 0 Then
    Return True
  Endif
  Return False
End


Public Sub HasPublicOrSub() As Boolean
  
  Return bPublicOrSubDef
  
End


Public Sub getBlocks() As Collection
  
  Return BlockDefined
  
End

Public Sub GetProgram() As String
  
  Return ProgramLines.Join("\n")
  
End

Public Sub DisplayWarnings()
  
  For Each sMessage As String In aWarnings
    Warning(sMessage)
  Next
  
End




