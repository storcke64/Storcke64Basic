' Gambas class file

Static Private $iConsole As Integer

Private $aHistory As New String[]
Private $bGotError As Boolean
Private $iHistory As Integer
Private $sCurrent As String

'Private $iLinkY As Integer
'Private $iLinkX As Integer
'Private $iLinkLen As Integer

'PUBLIC Shown AS Boolean

Public Sub _new()

  'Config.LoadWindow(ME, "/FOutput")
  Settings.Read(Me)
  ReadConfig
  
  chkCharset.Visible = System.Charset <> Desktop.Charset
  sepCharset.Visible = chkCharset.Visible
  btnUndock.Value = Settings["/FOutput/Undock", False]
  btnAbove.Value = Settings["/FOutput/KeepAbove", False]
  btnEcho.Value = Settings["/FOutput/Echo", False]
  OnProjectDebug
  
  'edtOutput.Styles[Highlight.Keyword].Underline = True
  'edtOutput.Styles[Highlight.Keyword].Bold = False
  'edtOutput.Styles[Highlight.Keyword].Color = Color.Blue
  'edtOutput.Overwrite = True
  'edtOutput.Flags[Editor.AlwaysShowCursor] = True
  'edtOutput.Flags[Editor.ShowDots] = False

End

Public Sub GetEditor() As TextEditor
  
  'Return edtOutput
  
End


Public Sub Clear()

  trmOutput.Clear
  btnSuspend.Value = False
  txtEnter.Clear
  $iHistory = $aHistory.Count
  SetFocus

End


Public Sub Insert(sText As String, Optional bCurrent As Boolean)

  If chkCharset.Value Then  
    Try sText = DConv$(sText)
  Endif

  If Not bCurrent Then 
    'edtOutput.Line = edtOutput.Lines.Count
    'edtOutput.Goto(edtOutput.Lines.Count, 10000)
  Endif
  
  'If Not Action["console"].Value Then Action["console"].Value = True

  trmOutput.Print(Replace(sText, "\n", "\r\n"))
  
End

Public Sub ReadConfig()

  Project.SetConsoleFont(trmOutput)
  MTheme.InitControl(trmOutput)

  Project.SetSmallFont(panToolbar)
  
  txtEnter.Font = trmOutput.Font
  lblEnter.Font = trmOutput.Font
  lblEnter.Font.Bold = True
  panEnter.H = txtEnter.Font.Height + 4

End

Public Sub trmOutput_KeyPress()

  If Key.Code = Key.Escape Then 
  
    Action["console"].Value = False

  Else If Key.Control Then

    If Key.Code = Key["L"] Then
      Clear
      Stop Event
    Else If Key.Code = Key["G"] Then 
      trmOutput.Print(Chr$(7))
      Stop Event
    Endif
    
  Endif

End

Public Sub Form_Close()

  If Not Me.Parent Then 
    'DEBUG "Write: "; ME.X;; ME.Y
    Settings.Write(Me)
  Endif
  'Action["console"].Value = FALSE
  'Settings.Write(ME)

End

' Public Sub Form_Show()
' 
'   trmOutput.AutoResize = True
'   'Action["console"].Value = TRUE
' 
' End

Public Sub btnClear_Click()

  Clear

End

Public Sub btnCopy_Click()

  trmOutput.Copy

End

Public Sub btnPaste_Click()

  trmOutput.Paste

End

Public Sub SetFocus()

  If panEnter.Visible And If Not txtEnter.ReadOnly Then
    txtEnter.SetFocus
  Else
    trmOutput.SetFocus
  Endif

End

Public Sub Form_GotFocus()

  SetFocus

End

Public Sub Form_Activate()

  SetFocus

End

Public Sub btnUndock_Click()

  Settings["/FOutput/Undock"] = btnUndock.Value
  OnProjectDebug
  FDebugInfo.UpdateView

End

' PUBLIC SUB Toggle(bShow AS Boolean)
'   
'   IF NOT btnUndock.Value THEN
'     'IF NOT Project.Running THEN 
'       FMain.ShowDebug(bShow)
'     'ENDIF 
'   ELSE 
'     ME.Visible = bShow
'   ENDIF
'   
' END

Public Sub OnProjectDebugState()

  txtEnter.ReadOnly = Design.IsRunning()  
  If txtEnter.HasFocus Then trmOutput.SetFocus
  
  If Design.IsStop() Then 
    trmOutput.Reset(True)
    btnSuspend.Value = False
    btnSuspend.Hide
  Else
    btnSuspend.Show
  Endif
  
End

Public Sub OnProjectDebug()
  
  btnAbove.Visible = Project.Running And btnUndock.Value
  If btnUndock.Value Then Me.Stacking = If(Project.Running And btnAbove.Value, Window.Above, Window.Normal)
  SetFocus
  
End


Public Sub btnAbove_Click()

  Settings["/FOutput/KeepAbove"] = btnAbove.Value
  OnProjectDebug
  
End

Public Sub Form_Open()

  If Not Me.Parent Then 
    Settings.Read(Me)
    'DEBUG "Read: "; ME.X;; ME.Y
  Endif
  
End

Public Sub trmOutput_Menu()

  mnuEditor.Popup

End

Public Sub trmOutput_GotFocus()

  Project.SetCurrentPopup(mnuEditor)
  FSearch.Update
  
End

Public Sub txtFind_KeyPress()

  If Key.Code = Key.F3 
    If Key.Normal Then 
      FSearch.FindNext
    Else If Key.Shift Then 
      FSearch.FindPrevious
    Endif
    Stop Event 
  Endif

End

Public Sub trmOutput_LostFocus()

  If Project.AboutToQuit Then Return
  FSearch.Update

End

Public Sub btnEdit_Click()

  Dim sPath As String
  Dim sText As String
  
  sText = trmOutput.Text
  If Not sText Then Return

  Inc $iConsole

  sPath = File.Dir(Temp$()) &/ $iConsole & ".console"
  File.Save(sPath, sText)
  Project.OpenFile(sPath)
  
  If Not Project.Running Then trmOutput.Clear

End


' Public Sub btnControl_Click()
' 
'   Design.Send(Chr$(Asc(Right$(Last.Text)) - 64))
' 
' End
' 
' Public Sub btnCtrlD_Click()
' 
'   Print #Design.GetProcess(), Chr$(4);
' 
' End

Public Sub txtEnter_Activate()

  Dim sText As String
  'Dim bSemiColon As Boolean
  Dim sVal As String

  sText = txtEnter.Text
  If $iHistory = $aHistory.Count Or If sText <> $aHistory[$iHistory] Then
    $aHistory.Add(txtEnter.Text)
    If $aHistory.Count > 256 Then $aHistory.Remove(0)
  Endif
  $iHistory = $aHistory.Count
  txtEnter.Clear

  If Design.IsRunning() Then

    'edtOutput.Insert("\n")
    If btnEcho.Value Then Insert(sText & "\n")
    Design.Send(sText & "\n")
    'Debug
    Stop Event

  Else

    sText = Trim(sText)
    If Not sText Then Return

    If Project.Running Then

      If btnEcho.Value Then Insert("Print " & sText & "\n")

      'edtOutput.Insert("\n")
      Design.Command("!\t" & sText)
      Stop Event

    Else

      If btnEcho.Value Then Insert("Print " & sText & "\n")

      Try sVal = Str(Eval(sText & "\n"))
      If Error Then
        txtEnter.Text = Error.Text
        txtEnter.Foreground = Color.Red
        $bGotError = True
      Else
        sVal = DConv$(sVal)
        'If Not bSemiColon Then sVal &= "\n"
        Insert(sVal & "\n")
      Endif
      Stop Event

    Endif

  Endif
  

End

Public Sub txtEnter_KeyPress()

  If $bGotError Then
    $bGotError = False
    txtEnter.Foreground = Color.Default
    txtEnter.Clear
  Endif
  
  If Key.Code = Key.Up Then
    If $iHistory Then
      If $iHistory = $aHistory.Count Then $sCurrent = txtEnter.Text
      Dec $iHistory
      txtEnter.Text = $aHistory[$iHistory]
    Endif
    Stop Event
  Else If Key.Code = Key.Down Then
    If $iHistory < $aHistory.Count Then
      Inc $iHistory
      If $iHistory = $aHistory.Count Then 
        txtEnter.Text = $sCurrent
      Else
        txtEnter.Text = $aHistory[$iHistory]
      Endif
    Endif
    Stop Event
  Else If Key.Code = Key.Home And If Key.Control Then
    trmOutput.Goto(0, 0)
    Stop Event
  Else If Key.Code = Key.End And If Key.Control Then
    trmOutput.Goto(0, trmOutput.Count - 1)
    Stop Event
  Else If Key.Code = Key.Escape Then
    Action["console"].Value = False
  Endif

End

Public Sub btnEcho_Click()

  Settings["/FOutput/Echo"] = btnEcho.Value

End

' Public Sub edtOutput_Highlight((Text) As String)
' 
'   If $iLinkLen = 0 Then Return
'   If $iLinkY <> TextHighlighter.Line Then Return
' 
'   TextHighlighter.Add(Highlight.Keyword, $iLinkLen)
' 
' End

' Public Sub edtOutput_MouseMove()
' 
'   Dim MX, MY As Integer
'   Dim X, Y As Integer
'   Dim sText As String
'   Dim iPos As Integer
'   Dim aScan As String[]
'   Dim iNewX As Integer
'   Dim iNewY As Integer
'   Dim iNewLen As Integer
'   
'   If Not edtOutput.Hovered Then Return
'   
'   Try MX = Mouse.X
'   If Not Error Then 
'     MY = Mouse.Y
'   Else
'     MX = Mouse.ScreenX - edtOutput.ScreenX
'     MY = Mouse.ScreenY - edtOutput.ScreenY
'   Endif
' 
'   X = edtOutput.ToColumn(MX, MY)
'   Y = edtOutput.ToLine(MY)
'   
'   If Y >= 0 And If X >= 0 Then
'   
'     sText = edtOutput[Y].Text
'     
'     iPos = InStr(sText, ": ")
'     If iPos > X Then
'       aScan = Scan(Left(sText, iPos - 1), "*.*.*")
'       If aScan.Count = 3 And If IsDigit(aScan[2]) Then 
'         iNewY = Y
'         iNewX = 0
'         iNewLen = iPos - 1
'       Endif
'     Endif
'   Endif
'   
'   If $iLinkLen Then 
'     $iLinkLen = 0
'     Try edtOutput[$iLinkY].Refresh
'   Endif
'   
'   If iNewLen Then 
'     $iLinkX = iNewX
'     $iLinkY = iNewY
'     $iLinkLen = iNewLen
'     edtOutput[iNewY].Refresh
'   Endif
'   
'   If $iLinkLen Then 
'     edtOutput.Mouse = Mouse.Pointing
'   Else
'     edtOutput.Mouse = Mouse.Default
'   Endif
' 
' End
' 
' Public Sub edtOutput_Leave()
' 
'   If $iLinkLen Then 
'     $iLinkLen = 0
'     Try edtOutput[$iLinkY].Refresh
'   Endif
'   
' End
' 
' Public Sub edtOutput_MouseDown()
' 
'   If $iLinkLen And If Mouse.Normal Then
'     If Not Project.Goto(Left$(edtOutput[$iLinkY].Text, $iLinkLen)) Then 
'       Stop Event
'     Endif
'   Endif
' 
' End
' 
' 
' Public Sub edtOutput_Scroll()
' 
'   edtOutput_MouseMove
' 
' End

Public Sub PrintExpr(sExpr As String)
  
  txtEnter.Text = sExpr
  txtEnter_Activate
  
End

Public Sub GetTerminal() As TerminalView
  
  Return trmOutput
  
End

Public Sub btnSuspend_Click()

  trmOutput.Suspended = btnSuspend.Value

End

' Public Sub UpdateWidth(W As Integer)
'   
'   If trmOutput.AutoResize Then Return
'   If Me.W <> W Then
'     trmOutput.ScreenWidth = (W - Style.ScrollbarSize) \ trmOutput.CharWidth
'   Endif
'   
' End

Static Public Sub CheckTerminalLink(hTerm As TerminalView)

  Dim sLine As String
  Dim iPos As Integer
  Dim iLen As Integer
  Dim iPos2 As Integer

  With hTerm.Link
    
    sLine = .Line
    iPos = String.Pos(sLine, .Pos)
    iPos2 = iPos
    
    While iPos > 0
      If Mid$(sLine, iPos, 1) Not Like "[A-Za-z0-9._]" Then Break 
      Dec iPos
    Wend
    Inc iPos
    
    Inc iPos2
    While iPos2 <= Len(sLine)
      If Mid$(sLine, iPos2, 1) Not Like "[A-Za-z0-9._]" Then Break 
      Inc iPos2
    Wend
    Dec iPos2
    
    iLen = iPos2 - iPos + 1
    If iLen <= 0 Then Return
    
    sLine = Mid$(sLine, iPos, iLen)
    If sLine Not Match "^[a-zA-Z_][a-zA-Z0-9_]*\\.[a-zA-Z_][a-zA-Z0-9_]*\\.[0-9]+" Then Return
    
    hTerm.Link.Select(String.Index(.Line, iPos) - 1, String.Len(sLine), "goto")
    
  End With

End

Public Sub trmOutput_Link()

  CheckTerminalLink(trmOutput)

End

Public Sub trmOutput_Click()
  
  If trmOutput.Link.Type = "goto" Then
    Project.Goto(trmOutput.Link.Text)
  Endif
  
End
